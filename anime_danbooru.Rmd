---
title: "danbooru tag poster"
author: "Yehong Deng"
date: "2024-02-27"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tm)
library(stringr)
library(sna)
library(igraph)
library(sand)
library(network)
library(igraphdata)
library(tidyverse)
library(splitstackshape)
library(reshape2)
library(qdapTools)
library(tidyr)
library(blockmodels)
library(sbm)
library(tidyverse)
library(tidygraph)
library(ggraph)
library(reshape2)
library(cluster)
library(circlize)
library(ggsankey)
library(RColorBrewer)
library(latentnet)
# To set current folder as your working directory.
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

```{r}
danbooru_in_month <- read.csv("image_in_month.csv")

danbooru_in_hour <- danbooru_in_month %>%
  filter(created_at <= 3600 + 1264803292)


id_tag_list <- danbooru_in_hour %>% 
  select(id, tags)


corpus <- Corpus(VectorSource(id_tag_list$tags))
corpus <- tm_map(corpus, content_transformer(tolower))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, removeWords, stopwords("english"))

cleaned_text <- sapply(corpus, function(x) paste(unlist(str_split(x, "\\s+")), collapse = " "))

id_tag_list$tags <- cleaned_text
```


```{r}
temp <- crossprod(
  as.matrix(
    cSplit_e(id_tag_list, "tags", " ", type = "character", 
             fill = 0, drop = TRUE)[-1]))

temp[upper.tri(temp, diag = TRUE)] <- NA

edge_list_df <- melt(temp, na.rm = TRUE) %>% 
  filter(value != 0) %>%
  mutate(from = gsub("tags_", "", Var1),
         to = gsub("tags_", "", Var2),
         weight = value) %>%
  select(c("from", "to", "weight"))
```

```{r}
top_100 <- edge_list_df %>%
  count(from, sort = TRUE) %>% # 对column_name列中的词进行计数并排序
  top_n(100) %>% # 选出出现次数最多的15个词
  arrange(desc(n))
# change top_50 to a list
top_100_list <- top_100$from

edge_list_df_100 <- edge_list_df %>%
  filter(from %in% top_100_list) %>%
  filter(to %in% top_100_list)
```

```{r}
anime <-graph_from_data_frame(edge_list_df_100, directed = FALSE)
l <- layout.kamada.kawai(anime)
plot(anime,vertex.label = NA,layout=l, vertex.size = 3)

anime_graph <- as_tbl_graph(edge_list_df_100, directed = FALSE)
anime_graph <- anime_graph %>%
  mutate(degree = centrality_degree(),
    community = group_leading_eigen())


ggraph(anime_graph, ) + 
  geom_node_point(aes(size = degree,
                      color = factor(community))) +
  geom_edge_link(alpha = 0.5)
```

```{r}
anime_fit <- ergmm(edge_list_df_100 ~ euclidean(d=2))
plot(anime_fit)
```

```{r}
anime_fit <- ergmm(edge_list_df_100 ~ euclidean(d=2, G = 3))
plot(anime_fit)
```


```{r}
anime.adj <- as_adj(anime_graph, sparse = FALSE)

anime_out <- BM_poisson("SBM", anime.adj)
str(anime_out)
anime_out$estimate()
#village_out$ICL
which.max(anime_out$ICL)

best_fit_membership_probs <- anime_out$memberships[[which.max(anime_out$ICL)]]$Z
clust_assignments <- apply(best_fit_membership_probs, 1, which.max)
plot(anime,
     vertex.color = clust_assignments,
     vertex.label = NA,layout=l, vertex.size = 3)

# subgraph of each of the three clusters
member1 <- which(clust_assignments == 1)
member2 <- which(clust_assignments == 2)
member3 <- which(clust_assignments == 3)



subgraph_1 <- induced_subgraph(anime, member1)
subgraph_2 <- induced_subgraph(anime, member2)
subgraph_3 <- induced_subgraph(anime, member3)
# plot the subgraphs
plot(subgraph1,layout=l, vertex.size = 10 * sqrt(authority.score(anime)$vector))

plot(subgraph_2,layout=layout.kamada.kawai, vertex.size = 10 * sqrt(authority.score(anime)$vector))

plot(subgraph_3,layout=l, vertex.size = 3)
```


```{r}
## setting the pal
pal <- c("#db5f57", "#db8557", "#dbaa57", "#dbd057", "#c0db57", "#9bdb57", "#75db57", "#57db5f", "#57db85", "#57dbaa", "#57dbd0", "#57c0db", "#579bdb", "#5775db", "#5f57db", "#8557db", "#aa57db", "#d057db", "#db57c0", "#db579b", "#db5775")
```


```{r}
# Extract 3 node lists
member_1 <- V(subgraph_1)$name
member_2 <- V(subgraph_2)$name
member_3 <- V(subgraph_3)$name
```

```{r}
# Create 3 edge lists for 3 subgraphs
sub_edge_list_1 <- edge_list_df_100 %>%
  filter(from %in% member_1) %>%
  filter(to %in% member_1)

sub_edge_list_2 <- edge_list_df_100 %>%
  filter(from %in% member_2) %>%
  filter(to %in% member_2)

sub_edge_list_3 <- edge_list_df_100 %>%
  filter(from %in% member_3) %>%
  filter(to %in% member_3)
```


```{r}
## Create 3 sub dataframes for 3 subgraphs
sub_1_sankey <- sub_edge_list_1 %>%
  ggsankey::make_long(from, to, value = weight)

sub_2_sankey <- sub_edge_list_2 %>%
  ggsankey::make_long(from, to, value = weight)

sub_3_sankey <- sub_edge_list_3 %>%
  ggsankey::make_long(from, to, value = weight)
```




```{r}
## Do sankey for subgraph 1
ggplot(
  sub_1_sankey,
  aes(
    x = x,
    next_x = next_x,
    node = node,
    next_node = next_node,
    value = value,
    fill = node
  )
) +
  geom_sankey(flow.alpha = 0.6,
              width = 0.01) +
  
  theme_sankey() +
  labs(x = NULL) +
  theme(legend.position = "none") +
  scale_x_discrete(labels = c("Genre_1", "Genre_2")) +
  geom_sankey_text(
    data = filter(sub_1_sankey, x == "from"),
    aes(label = paste0(node, "   "), color = node),
    hjust = 1
  ) +
  geom_sankey_text(
    data = filter(sub_1_sankey, x== "to"),
    aes(label = paste0("   ", node), color = next_node),
    hjust = 0
  )




## Do sankey for subgraph 2
ggplot(
  sub_2_sankey,
  aes(
    x = x,
    next_x = next_x,
    node = node,
    next_node = next_node,
    value = value,
    fill = node
  )
) +
  geom_sankey(flow.alpha = 0.6,
              width = 0.01) +
  scale_fill_manual(values = pal) +
  theme_sankey() +
  labs(x = NULL) +
  theme(legend.position = "none") +
  scale_x_discrete(labels = c("Genre_1", "Genre_2")) +
  geom_sankey_text(
    data = filter(sub_2_sankey, x == "from"),
    aes(label = paste0(node, "   "), color = node),
    hjust = 1
  ) +
  geom_sankey_text(
    data = filter(sub_2_sankey, x == "to"),
    aes(label = paste0("   ", node), color = node),
    hjust = 0
  ) 



## Archive for a success version
  # ggplot(
  #   Danbooru_sankey,
  #   aes(
  #     x = x,
  #     next_x = next_x,
  #     node = node,
  #     next_node = next_node,
  #     value = value,
  #     fill = node
  #   )
  # ) +
  # geom_sankey(flow.alpha = 0.6,
  #             width = 0.01) +
  # scale_fill_manual(values = pal) +
  # theme_sankey() +
  # labs(x = NULL) +
  # theme(legend.position = "none") +
  # scale_x_discrete(labels = c("Genre_1", "Genre_2")) +
  # geom_sankey_text(
  #   data = filter(Danbooru_sankey, x == "from"),
  #   aes(label = paste0(node, "   "), color = node),
  #   hjust = 1
  # ) +
  # geom_sankey_text(
  #   data = filter(Danbooru_sankey, x == "to"),
  #   aes(label = paste0("   ", node), color = node),
  #   hjust = 0
  # ) +
  # scale_color_manual(values = pal)
 

## Do sankey for subgraph 3
ggplot(
  sub_3_sankey,
  aes(
    x = x,
    next_x = next_x,
    node = node,
    next_node = next_node,
    value = value,
    fill = node
  )
) +
  geom_sankey(flow.alpha = 0.6,
              width = 0.01) +
  scale_fill_manual(values = pal) +
  theme_sankey() +
  labs(x = NULL) +
  theme(legend.position = "none") +
  scale_x_discrete(labels = c("Genre_1", "Genre_2")) +
  geom_sankey_text(
    data = filter(sub_3_sankey, x == "from"),
    aes(label = paste0(node, "   "), color = node),
    hjust = 1
  ) +
  geom_sankey_text(
    data = filter(sub_3_sankey, x == "to"),
    aes(label = paste0("   ", node), color = node),
    hjust = 0
  ) 


```


```{r}
# Since the sankey plot is not very informative, we can use the chord diagram to visualize the relationship for subgraph1
# Use the chorddiag package to visualize the relationship between the genres


chord_Sub_1 <- sub_edge_list_1 %>%
  group_by(from, to) %>%
  summarize(flowTotal = sum(weight, na.rm = TRUE)) %>%
  ungroup() 

chordDiagram(chord_Sub_1)


# Do the same to subgraph 2
chord_Sub_2 <- sub_edge_list_2 %>%
  # filter out the tagme tag
  filter(!from %in% "tagme",!to %in% "tagme") %>%
  group_by(from, to) %>%
  summarize(flowTotal = sum(weight, na.rm = TRUE)) %>%
  ungroup() 

chordDiagram(chord_Sub_2)
```

